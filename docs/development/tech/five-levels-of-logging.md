# [译+] 日志的5个级别

日志是软件开发中的一个概念，在这个概念中，几乎所有软件都能从日志中获益良多。它是在开始一个大型项目时设置的第一个系统。关于它的优点有很多，但我会把它留给其他人(
或某个时候)来讲, 现在我想谈谈日志级别。

日志级别是除了基本的 `滚动文本行` 日志之外一个出色的(并且很简单，因为它们常常是同时进行的)
概念。每个消息被分配一个级别，表示消息的重要性或其影响的严重性。例如，
_您的计算机着火了_ 可能是一条 _关键_ 消息，而 _无法找到配置文件_ 可能会被赋予较低的重要性级别。

许多应用程序和库根据自己或用户的需要定义自己的级别. 当然，做这些事情没有固定的模式，我想谈谈我发现的五种(或六种，或四种)
是最关键的，用于建立你自己的认知

我还会讨论我倾向于为这些级别分配的颜色(或者说，样式)，因为颜色(或样式)不同的日志更容易有据可循。使用它将使你的程序变得清晰可辨,
无论是从远处看到还是通过未经训练的人!但谁知道呢，你可能有一次离开电脑吃午饭。

## Fatal(致命/事故)

错误已经发生——不，抱歉，发生了 _致命_ 错误。我们现在要辞职了。好运！

这应该是高于 _Error_ 的，但我用的比 _Trace_
要少，所以它在文章的地步。致命错误，顾名思义，是指不可能继续运行程序的情况。正是因为这个原因，他们没有理由拥有自己的级别——每次调用只能看到一个。但是致命错误确实有其常见的地方，可以恢复(
或者重启)，所以有必要提一下。

**样式**: 如果你还没有用完样式，那就比 _Error_ 更引人注目。我用紫色的文本; 类似于红色 _Error_ 但有些差别，但当你需要它的时候，它比较清晰

```
- 内存不足
- 无法分配 65536 字节的磁盘空间
- 许可证过期，切换到自由软件
```

## Error (错误)

发生错误。这是毫无疑问的(或者很有可能没有必要去区分)。错误的来源可能是外部的，但人们应该对此关注。

对于需要注意的特定错误情况，可以使用此选项。大多数抛出的异常，如果不能优雅地处理，就会出现错误。

**样式**:能引起注意的东西. 我使用红色文本(在我的黑色终端背景上)。

```
- 无法找到关键文件(例如无法找到支付配置文件)
- 错误处理数据:[这里进行堆栈跟踪或作为后续调试消息]
- 连接数据库错误
- 签名失败(包含支付, 请求, 回调)
- 未知的错误信息, 但肯定会导致失败
```

## Warning(警告)

可能发生了错误。仅仅是一个日志信息，无法分析情况。人们应该 _可能_ 去调查这件事。

这可能是平行宇宙中的一个错误。它可能是潜在的当前或未来问题的提示(响应缓慢、连接中断、内存不足……)
，也可能是程序处理的错误情况的通知(但希望 _不_
必须再做一次，非常感谢)。

**样式:** 一些吸引注意力但又不太烦人的东西，以防出现暂时的问题，让你在一段时间内无法自顾不暇。区别于错误的样式, 使用黄色文本。

```
- 连接关闭，在2s内重新连接
- 无法找到 logging.conf[在配置文件中指定]，返回到默认配置
- 30秒后连接尝试超时
- 获取 FileVersionTooOldException ，返回到 Version12Parser
```

## Info(消息)

通知用户操作或状态更改, 程序继续运行。

Info可能是应该公开的最详细的级别(一般的、非技术的)
用户。它是你不介意被大声读给你听的东西。这是在你最喜欢的科幻电影《太空船》的舰桥上对船长宣布的。它应该包含很少的技术细节;可能只有你的普通用户感兴趣的内容(
例如文件名)。

**样式**:从下面级别中脱颖而出的内容。我使用白色文本。

```
- 代理初始化
- 载入保存 "yeti02"
- 开始加速运行
- 当前目录为 “/tmp”
- 建立上行
- 渲染完成，使用42.999s
```

## Debug(调试)

如果你能读懂这个，你就离做程序员太近了。

这就是为什么要保存日志文件。这就是修复bug所需要的。这是开发人员想要得到的东西。

_Debug_ 是保存程序流和其他技术内容的首选级别。除非它覆盖了大量的日志(在这种情况下，跟踪可能是更好的级别)
或更高级的消息显然更合适，否则您的调试消息可能值得保留，因为你已经考虑过编写它了。如果结果是与另一个调试或更高级别的消息一一对应，而不包含更多信息，那么您可以考虑删除它。

**样式** : 容易被忽视的东西。我使用浅灰色/米色文本，我的终端的默认文本颜色。
> ps : 正常生产环境不会存在这个东西

```nginx
- 从 “/etc/octarine/octarine.conf” 中读取配置
- 覆盖配置文件 “/home/aib/.octarinerc”
- 分析完毕，建筑图…
- 以“用户”身份连接 server:4242
- 发送 2 条消息
- 渲染时间细分:
- Foo 0.990秒
- Bar 42.009秒
```

## Trace(追踪)

这里有一些与技术无关的细节，除非你恰巧在寻找它们。

_Trace_ 是详细的调试信息，您可能不希望一直启用它(除非您向保存日志的人出售硬盘驱动器)。它可以包含诸如调用了哪些函数(
因此命名)
或与客户机交换了哪些网络数据包之类的信息。这对于捕获低级错误很好，但通常只有在您将它们的位置缩小到两个调试消息之间时才会这样做。

跟踪消息将主要包含您已经可以猜到的信息("Debug says 'logging in', so this is the login packet")
，因此，除非您的假设是错误的，否则可能不会有什么帮助。 ("Wait, is that
a log_out_?!", "Hmm,  `foo`  should be called here. Why isn't  `foo`'s Trace being printed then?")

**样式:** 在 _Debug_ 日志中可能丢失的东西。我使用深灰色，虽然它通常是禁用的。

```
- 调用函数 "foo" 使用参数 ("baz", "bar", 42)
- ->GET / HTTP/1.1\nHost: localhost\n\n
- 获取到:  <?xml version="1.0" encoding="UTF-8" ?>\n<ohboy>\n  [...]
```

## 附录

任何相关的日志API或库都应该有内置的级别(并且可能支持用户定义级别)。以下是一些常用使用的方法，以供参考:

- Linux's  [printk](https://en.wikipedia.org/wiki/Printk#Logging_Levels)
- Python's  [logging](https://docs.python.org/library/logging.html#logging-levels)
- Java's  [java.util.logging.Level](https://docs.oracle.com/javase/6/docs/api/java/util/logging/Level.html)  or
  log4j's  [org.apache.log4j.Level](https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html)
- Javascript's various console._level_  calls ([WHATWG's](https://console.spec.whatwg.org/#contents)
  or  [Node.js'](https://nodejs.org/api/console.html#toc)
  Console API specs)
- NLog's  [log levels](https://github.com/nlog/nlog/wiki/Log-levels)

